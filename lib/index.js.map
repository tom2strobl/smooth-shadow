{"version":3,"file":"index.js","sources":["../src/bezier.js","../src/index.ts"],"sourcesContent":["/* eslint-disable yoda */\n/* eslint-disable no-plusplus */\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nconst NEWTON_ITERATIONS = 4\nconst NEWTON_MIN_SLOPE = 0.001\nconst SUBDIVISION_PRECISION = 0.0000001\nconst SUBDIVISION_MAX_ITERATIONS = 10\n\nconst kSplineTableSize = 11\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0)\n\nconst float32ArraySupported = typeof Float32Array === 'function'\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1\n}\nfunction C(aA1) {\n  return 3.0 * aA1\n}\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT\n}\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1)\n}\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX\n  let currentT\n  let i = 0\n  do {\n    currentT = aA + (aB - aA) / 2.0\n    currentX = calcBezier(currentT, mX1, mX2) - aX\n    if (currentX > 0.0) {\n      aB = currentT\n    } else {\n      aA = currentT\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS)\n  return currentT\n}\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2)\n    if (currentSlope === 0.0) {\n      return aGuessT\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX\n    aGuessT -= currentX / currentSlope\n  }\n  return aGuessT\n}\n\nfunction LinearEasing(x) {\n  return x\n}\n\nexport default function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range')\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing\n  }\n\n  // Precompute samples table\n  const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize)\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2)\n  }\n\n  function getTForX(aX) {\n    let intervalStart = 0.0\n    let currentSample = 1\n    const lastSample = kSplineTableSize - 1\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize\n    }\n    --currentSample\n\n    // Interpolate to provide an initial guess for t\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample])\n    const guessForT = intervalStart + dist * kSampleStepSize\n\n    const initialSlope = getSlope(guessForT, mX1, mX2)\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2)\n    } else if (initialSlope === 0.0) {\n      return guessForT\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2)\n    }\n  }\n\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0 || x === 1) {\n      return x\n    }\n    return calcBezier(getTForX(x), mY1, mY2)\n  }\n}\n","import BezierEasing from './bezier'\n\nconst lerp = (x: number, y: number, a: number) => x * (1 - a) + y * a\nconst clamp = (a: number, min = 0, max = 1) => Math.min(max, Math.max(min, a))\nconst invlerp = (x: number, y: number, a: number) => clamp((a - x) / (y - x))\n\nconst roundPixel = (num: number): number => Math.round(num * 10) / 10\nconst roundTransparency = (num: number): number => Math.round(num * 1000) / 1000\n\ntype GetSmoothShadowProps = {\n  distance?: number // 1-1000\n  intensity?: number // 0-1\n  sharpness?: number // 0-1\n  color?: [number, number, number] // [0-255, 0-255, 0-255]\n  lightPosition?: [number, number] // [-1 - 1, -1 - 1], where 0 is the center\n}\n\nexport const getSmoothShadow = ({\n  distance = 100,\n  intensity = 0.5,\n  sharpness = 0.5,\n  color = [0, 0, 0],\n  lightPosition = [-0.35, -0.5]\n}: GetSmoothShadowProps): string => {\n  // in terms of performance it makes sense to limit a maximum\n  const maxDistance = 2000\n  const maxLayers = 24\n  // clamp user values so the result doesnt go apeshit\n  const cdistance = clamp(distance * 2, 0, maxDistance)\n  const cintensity = clamp(intensity, 0, 1)\n  const csharpness = clamp(sharpness, 0, 1)\n  // the fractional distance to the maximum 0-1\n  const interpolatedDistance = invlerp(1, maxDistance, cdistance)\n  // the more distance, the more layers\n  const amountEasing = BezierEasing(0.25, 1 - interpolatedDistance, 0.5, 1)\n  // dont forget to round since we can only handle an integer amount of layers\n  const amountLayers = Math.round(maxLayers * amountEasing(interpolatedDistance))\n  // no reason to make this dynamic as it always looks good\n  const distanceTransparency = BezierEasing(0, 0.3, 0, 0.06)\n  // we want short distances to have enough opacity to look good\n  const transparencyBase = (distanceTransparency(interpolatedDistance) / interpolatedDistance) * 6.5\n  // now factor in intensity\n  const finalTransparency = (transparencyBase / maxLayers) * cintensity\n  // no reason to make this dynamic as it always looks good\n  const transparencyEasing = BezierEasing(0, 1, 0.8, 0.5)\n  // take light position into consideration\n  const distanceX = cdistance * (lightPosition[0] * -1)\n  const distanceY = cdistance * (lightPosition[1] * -1)\n  // maxBlur scales with distance\n  const maxBlur = lerp(200, 500, interpolatedDistance)\n  // factor in sharpness to base blur value\n  const finalBlur = lerp(100, maxBlur, csharpness)\n  // this one's a little tricky, but for good looks we want multiple layers of ease\n  const blurSharpnessEase = BezierEasing(1, 0, 1, 0)\n  const easingBlurSharpness = lerp(0, 2, blurSharpnessEase(1 - csharpness))\n  const blurEasing = BezierEasing(1, easingBlurSharpness, 1, easingBlurSharpness)\n  // closer distances need to be paired with sharpness slightly differently to look good\n  const easingSharpness = lerp(0, 0.075, 1 - csharpness)\n  const distanceEasing = BezierEasing(1, easingSharpness, 1, easingSharpness)\n  // iterate of the all layers and generate the final box-shadow string\n  return Array.from(Array(amountLayers))\n    .map((_, i) => {\n      const transparencyCoeff = transparencyEasing(i / amountLayers)\n      const distanceCoeff = distanceEasing(i / amountLayers)\n      const blurCoeff = blurEasing(i / amountLayers)\n      const x = roundPixel(distanceX * distanceCoeff)\n      const y = roundPixel(distanceY * distanceCoeff)\n      const b = roundPixel(finalBlur * blurCoeff)\n      const t = roundTransparency(finalTransparency * transparencyCoeff)\n      return `${x}px ${y}px ${b}px rgba(${color[0]},${color[1]},${color[2]},${t})`\n    })\n    .join(', ')\n}\n"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","let","currentX","currentT","i","Math","abs","newtonRaphsonIterate","aGuessT","currentSlope","LinearEasing","x","bezier","mY1","mY2","Error","sampleValues","Array","intervalStart","currentSample","lastSample","dist","initialSlope","guessForT","lerp","y","a","clamp","min","max","invlerp","roundPixel","round","num","roundTransparency","getSmoothShadow","distance","intensity","sharpness","color","lightPosition","cdistance","cintensity","csharpness","interpolatedDistance","amountEasing","BezierEasing","amountLayers","finalTransparency","transparencyEasing","distanceX","distanceY","maxBlur","finalBlur","blurSharpnessEase","easingBlurSharpness","blurEasing","easingSharpness","distanceEasing","from","map","_","transparencyCoeff","distanceCoeff","blurCoeff","b","t","join"],"mappings":"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"}