{"version":3,"file":"index.js","sources":["../src/bezier.js","../src/index.ts"],"sourcesContent":["/* eslint-disable yoda */\n/* eslint-disable no-plusplus */\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nconst NEWTON_ITERATIONS = 4\nconst NEWTON_MIN_SLOPE = 0.001\nconst SUBDIVISION_PRECISION = 0.0000001\nconst SUBDIVISION_MAX_ITERATIONS = 10\n\nconst kSplineTableSize = 11\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0)\n\nconst float32ArraySupported = typeof Float32Array === 'function'\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1\n}\nfunction C(aA1) {\n  return 3.0 * aA1\n}\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT\n}\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1)\n}\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX\n  let currentT\n  let i = 0\n  do {\n    currentT = aA + (aB - aA) / 2.0\n    currentX = calcBezier(currentT, mX1, mX2) - aX\n    if (currentX > 0.0) {\n      aB = currentT\n    } else {\n      aA = currentT\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS)\n  return currentT\n}\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2)\n    if (currentSlope === 0.0) {\n      return aGuessT\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX\n    aGuessT -= currentX / currentSlope\n  }\n  return aGuessT\n}\n\nfunction LinearEasing(x) {\n  return x\n}\n\nexport default function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range')\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing\n  }\n\n  // Precompute samples table\n  const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize)\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2)\n  }\n\n  function getTForX(aX) {\n    let intervalStart = 0.0\n    let currentSample = 1\n    const lastSample = kSplineTableSize - 1\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize\n    }\n    --currentSample\n\n    // Interpolate to provide an initial guess for t\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample])\n    const guessForT = intervalStart + dist * kSampleStepSize\n\n    const initialSlope = getSlope(guessForT, mX1, mX2)\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2)\n    } else if (initialSlope === 0.0) {\n      return guessForT\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2)\n    }\n  }\n\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0 || x === 1) {\n      return x\n    }\n    return calcBezier(getTForX(x), mY1, mY2)\n  }\n}\n","import BezierEasing from './bezier'\n\nconst lerp = (x: number, y: number, a: number) => x * (1 - a) + y * a\nconst clamp = (a: number, min = 0, max = 1) => Math.min(max, Math.max(min, a))\nconst invlerp = (x: number, y: number, a: number) => clamp((a - x) / (y - x))\n\nconst roundPixel = (num: number): number => Math.round(num * 10) / 10\nconst roundTransparency = (num: number): number => Math.round(num * 1000) / 1000\n\ntype GetSmoothShadowFunction = (\n  distance?: number,\n  intensity?: number,\n  sharpness?: number,\n  rgb?: [number, number, number]\n) => string\n\nexport const getSmoothShadow: GetSmoothShadowFunction = (\n  rawDistance = 100,\n  rawIntensity = 0.5,\n  rawSharpness = 0.5,\n  rgb = [0, 0, 0]\n) => {\n  // in terms of performance it makes sense to limit a maximum\n  const maxDistance = 2000\n  const maxLayers = 24\n  // clamp user values so the result doesnt go apeshit\n  const distance = clamp(rawDistance * 2, 0, maxDistance)\n  const intensity = clamp(rawIntensity, 0, 1)\n  const sharpness = clamp(rawSharpness, 0, 1)\n  // the fractional distance to the maximum 0-1\n  const interpolatedDistance = invlerp(1, maxDistance, distance)\n  // the more distance, the more layers\n  const amountEasing = BezierEasing(0.25, 1 - interpolatedDistance, 0.5, 1)\n  // dont forget to round since we can only handle an integer amount of layers\n  const amountLayers = Math.round(maxLayers * amountEasing(interpolatedDistance))\n  // no reason to make this dynamic as it always looks good\n  const distanceTransparency = BezierEasing(0, 0.3, 0, 0.06)\n  // we want short distances to have enough opacity to look good\n  const transparencyBase = (distanceTransparency(interpolatedDistance) / interpolatedDistance) * 6.5\n  // now factor in intensity\n  const finalTransparency = (transparencyBase / maxLayers) * intensity\n  // no reason to make this dynamic as it always looks good\n  const transparencyEasing = BezierEasing(0, 1, 0.8, 0.5)\n  // we like it if the light source is closer to the center and generally speaking we want some shadow left at the top and left as well\n  const distanceX = distance * 0.5\n  const distanceY = distance * 0.75\n  // maxBlur scales with distance\n  const maxBlur = lerp(200, 500, interpolatedDistance)\n  // factor in sharpness to base blur value\n  const finalBlur = lerp(100, maxBlur, sharpness)\n  // this one's a little tricky, but for good looks we want multiple layers of ease\n  const blurSharpnessEase = BezierEasing(1, 0, 1, 0)\n  const easingBlurSharpness = lerp(0, 2, blurSharpnessEase(1 - sharpness))\n  const blurEasing = BezierEasing(1, easingBlurSharpness, 1, easingBlurSharpness)\n  // closer distances need to be paired with sharpness slightly differently to look good\n  const easingSharpness = lerp(0, 0.075, 1 - sharpness)\n  const distanceEasing = BezierEasing(1, easingSharpness, 1, easingSharpness)\n  // iterate of the all layers and generate the final box-shadow string\n  return Array.from(Array(amountLayers))\n    .map((_, i) => {\n      const transparencyCoeff = transparencyEasing(i / amountLayers)\n      const distanceCoeff = distanceEasing(i / amountLayers)\n      const blurCoeff = blurEasing(i / amountLayers)\n      const x = roundPixel(distanceX * distanceCoeff)\n      const y = roundPixel(distanceY * distanceCoeff)\n      const b = roundPixel(finalBlur * blurCoeff)\n      const t = roundTransparency(finalTransparency * transparencyCoeff)\n      return `${x}px ${y}px ${b}px rgba(${rgb[0]},${rgb[1]},${rgb[2]},${t})`\n    })\n    .join(', ')\n}\n"],"names":["BezierEasing"],"mappings":"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"}